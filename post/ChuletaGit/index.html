<!DOCTYPE html>
<html lang="es-es">
<head>
	<title>Chuleta Git Consola&middot; lPinchol Moon&#39;s Blog</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="author" content="lPinchol, Moon">
	<meta name="description" content="un blog sobre mi, juegos, desarrollo y anime">
	<meta name="keywords" content="Moon,Pincho,Dev">
	<meta name="generator" content="Hugo 0.17" />

	<!-- CSS -->
	<link rel="stylesheet" href="http://lpinchol.github.io/css/main.css">

	<!--Favicon-->
	<link rel="shortcut icon" href="http://lpinchol.github.io/favicon.ico" type="image/x-icon">

	<!-- RSS -->
	

	<!-- Font Awesome -->
	<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">

	<!-- Google Fonts -->
	<link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic" rel="stylesheet" type="text/css">
</head>

<body>
    <header class="site-header">
	<div class="branding">
		<a href="http://lpinchol.github.io/">
		<img class="avatar" src="http://lpinchol.github.io/img/avatar.png" alt=""/>
		</a>
		<h1 class="site-title">
			<a href="http://lpinchol.github.io/">lPinchol Moon&#39;s Blog</a>
		</h1>
	</div>
	<nav class="site-nav">
		<ul>
	      	<li><a href="/about/"> About </a></li>

	      	<li>
	<a href="http://lpinchol.github.io/" title="">
		<i class="fa fa-fw fa-home"></i>
	</a>
</li>

<li>
	<a href="http://lpinchol.github.io/index.xml" title="Subscribirte">
		<i class="fa fa-fw fa-rss"></i>
	</a>
</li>

<li>
	<a href="mailto:moon@lpinchol.xyz" title="Email">
		<i class="fa fa-fw fa-envelope"></i>
	</a>
</li>



<li>
	<a href="https://bitbucket.org/lPinchol" title="Bitbucket">
		<i class="fa fa-fw fa-bitbucket"></i>
	</a>
</li>







<li>
	<a href="https://github.com/lPinchol" title="GitHub">
		<i class="fa fa-fw fa-github"></i>
	</a>
</li>

























	    </ul>
	</nav>
</header>


    <div class="content">
    <article class="feature-image">
		<header style="background-image: url('http://lpinchol.github.io/img/img050.png')">
			<h1 class="title">Chuleta Git Consola</h1>
		</header>

	<section class="post-content">
		

<h1 id="chuleta-de-git-consola">Chuleta de Git (Consola)</h1>

<p>==============</p>

<h1 id="probando-la-consola-y-comandos-para-git">&gt; Probando la consola y comandos para git</h1>

<p>##Una vez instalado GIT, se hay que configurar:</p>

<p>git config &ndash;global user.name &ldquo;&rdquo;
git config &ndash;global user.email &ldquo;&rdquo;</p>

<p>##Generando la public key:</p>

<p>ssh-keygen</p>

<p>##Leyendo tu llave para copiarla a GitHub</p>

<p>cat ~/.shh/id_rsa.pub</p>

<p>##Arrancando tu proyecto:</p>

<p>git init                        //Iniciar git</p>

<p>git clone git:ruta github       //Clona un repositorio</p>

<p>touch README                    //Creas readme</p>

<p>echo &ldquo;Texto&rdquo; &gt; Readme.md        //Crea un archivo con texto en su interior y se llamara readme.md</p>

<p>git add README                  //Añades readme</p>

<p>git status                      //Muestra el estado de git</p>

<p>git add .                       //Añade todos los archivos</p>

<p>git commit -m &ldquo;tu primer comm&rdquo;  //Añadir commit</p>

<p>git remote add origin           //Añadimos el remoto</p>

<p>git push origin master          //Mandas los commits</p>

<p>git pull origin master          //Recibir la actualizacion</p>

<p>git branch                      //Te muestra todas las ramas</p>

<p>git pull origin master          //Recibir la actualizacion</p>

<p>git branch dev                  //Creacion de un branch</p>

<p>git branch -d dev               //Eliminacion de la rama dev</p>

<p>git checkout dev                //Cambiar a la rama Dev</p>

<p>gitk                            //Saca la interfaz grafica</p>

<p>##Todos los comandos:</p>

<p>Chuleta de comandos git</p>

<pre><code>* git help &lt;command&gt;
* git clone &lt;uri&gt; namedir # clona usando como nombre de directorio namedir.
* git add &lt;dir&gt; # añade recursivamente todos los archivos del dir.
* git diff --staged # compares staged changes with last commit
* git commit -v # muestra el diff en el editor
* git commit -a -m ” # automatically stage tracked files. No hace falta git add
* git rm --cached &lt;file or regexp&gt; # Git no realiza un seguimiento del archivo, pero los deja en el directorio de trabajo. Útil cuando se olvida añadir archivos al .gitignore y ya hemos agregado dichos archivos al repositorio.
* git rm &lt;file&gt; # borrarlos con git siempre.
* git rm -f &lt;file&gt; # si ya está modificado y en el index.
* git mv &lt;file&gt; &lt;renamed_file&gt;
* gitk # tcl/tk. Herramienta gráfica para git
* git commit --amend # Modificar el mensaje del último commit
* git reset HEAD &lt;file&gt; # to unstage
* git checkout -- &lt;file&gt; # Descartar cambios en el directorio de trabajo.
</code></pre>

<p>AÑADIR ARCHIVOS
    * git add -i # interactive staggin
    * git add -p # crea patch</p>

<p>STASH
    * git stash # guarda el estado en una pila y limpia el directorio para poder cambiar de rama
    * git stash list # muestra la pila
    * git stash apply # vuelve al estado original del dir. Stash{n} especifica uno concreto Y &ndash;index reaplica los cambios stagged
    * git stash pop # elimina el primero en la pila. O drop</p>

<pre><code>* git log -p -2 # Muestra 2 últimos commits con diff
* git log --stat
* git log --pretty &lt;short|full|fuller&gt;
* git log --pretty=format:”%h - %an, %ar : %s”
* git log --pretty=format;”%h %s” --graph
* git log --since=2.weeks
* git log &lt;branch&gt; --not master # Muestra commit de &lt;branch&gt; sin incluir los de master
* git log --abbrev-commit --pretty=oneline
* git diff master…contrib # Muestra solo el trabajo que la rama contrib actual ha introducido desde su antecesor común con master
* git log &lt;branch1&gt;..&lt;branch2&gt; # Commits de branch2 que no están en branch1
* git log origin/master..master # Muestra qué commits se van a enviar al servidor
* git log origin/master.. # Igual que el anterior. Se asume master o HEAD
* git log refA refB --not refC # commits en refA y refB que no están en refC
* git log master…experiment # commits de master o experiment, pero sin ser comunes. Con --left-right indica a qué rama pertenece cada uno
</code></pre>

<p>REMOTES # repos en internet
    * git remote -v # lista los repos remotos
    * git remote add [shortname] [url] # crea nuevo remote, es posible descargar el contenido de ese repo con git fetch [shortname]. Master branch en [shortcode]/master
    * git fetch <remote> # descarga trabajo nuevo a máquina local, no sobreescribe nada tuyo. ( git pull sí hace merge automaticamente si se esta realizando un seguimiento de esa branch)
    * git push [remote-name] [branch-name] # sii nadie ha hecho push antes
    * git remote show [remote-name] # inspecciona remote.
    * git remote rename <old-name> <new-name> # también renombra branches: quedaría <new-name>/master
    * git remote rm <remote-name> # p.e si el contribuidor ya no contribuye más</p>

<p>Añadir varios repositorios remotos
    * git remote add bitbucket git@bitbucket.org:algui91/grado_informatica_tsi_practicas.git # Añadir un nuevo repositorio remoto con el nombre deseado. Por ejemplo si ya tenemos uno en github y queremos añadir otro para bitbucket
    * git push -u bitbucket –all # Subir el proyecto a bitbucket. A partir de ahora se puede seleccionar a qué repo publicar con*git push nombre_repo_remoto</p>

<p>TAGGINGmarcan puntos importantes en la histtoria del repo ( releases )
    * git tag # muestra las etiquetas actuales
    * git tag -l ‘v1.4.2.*’ # acepta regex
    * Dos tipos de tag:
    * Lightweight : puntero a commit ( branch que no cambia )
    * Annotated : se almacenan como objetos en la db, con checksum, nombre del creador, email, fecha, mensaje, posibilidad de firmarla con GPG. ( recomendada )</p>

<pre><code>* git tag -a &lt;tagname&gt; -m ‘mensaje’ # annotated tag
* git show &lt;tag-name&gt; # muestra información asociada.
* git tag -s &lt;tag-name&gt; -m ‘message’ # la firma con gpg
* git tag &lt;tag-name&gt; # lightweight tag
* git tag -v &lt;tag-name&gt; # verifica tags firmadas
* git tag -a &lt;tag-name&gt; [commit-chksum] # crea tag para commit con dicho chksum
* Por defecto no se transfieren los tags, para subirlos al servidor:
* git push origin [tag-name] # una sola
* git push origin --tags # Enviar todas

* Para usar GPG y firmar tags, hay que subir la clave pública al repositorio:
* gpg --list-keys # Coges la id pública
* gpg -a --export &lt;id&gt; | git hash-object -w --stdin # Copia el SHA-1 devuelto
* git tag -a maintainer-gpg-pub &lt;SHA-1&gt;
* git push --tags # Comparte la clave con todos los usuarios
* git show maintainer-gpg-pub | gpg --import # Cada usuario importa la clave así
* git show &lt;tag&gt; # Devuelve más información sobre la etiqueta
* git tag -d nombre_tag # eliminar la etiqueta
* git push origin :refs/tags/nombre_tag # Eliminar la etiqueta del repositorio remoto.
</code></pre>

<h2 id="branch">BRANCH</h2>

<h1 id="las-ramas-simplememte-son-punteros-a-distintos-snapshots">las ramas simplememte son punteros a distintos snapshots</h1>

<pre><code>* 
    * git branch &lt;nombre-rama&gt; # crea rama. Puntero al commit actual
    * git checkout &lt;nombre-rama&gt; # cambiar a la rama especificada.
    * git checkout -b &lt;nombre-rama&gt; # crea y cambia de rama
    * git merge &lt;rama&gt; # Mezcla la rama actual con &lt;rama&gt;
    * git branch -d &lt;rama&gt; # elimina la rama
    * git push origin --delete &lt;branchName&gt; # Elimina una rama del servidor
    * git mergetool # Herramienta gráfica para resolver conflictos
    * git branch # lista ramas
    * git branch -v # lista ramas mostrando último commit
    * git branch --merged # lista ramas que han sido mezcladas con la actual. Si no tienen un *, pueden borrarse, ya que significa que se han incorporado los cambios en la rama actual.
    * git branch --no-merged # lista ramas que no han sido incorporadas a la actual. ## REMOTE BRANCHES

    * git fetch origin # Descarga el contenido del servidor
    * git push &lt;remote&gt; &lt;branch&gt; # Las ramas no se suben por defecto, has de subirlas explícitamente
    * git push &lt;remote&gt; &lt;branch&gt;:&lt;nuevoNombre&gt; # Igual que la de arriba, pero en el servidor se llama a la rama con nuevoNombre en lugar de branch
    * Cuando se hace un git fetch que trae consigo nuevas ramas remotas, no se disponen de ellas localmente, solo se dispone de un puntero a la rama remota que no es editable. Para poder trabajar sobre esa rama, es necesario crearla Por ejemplo:
    * git fetch origin # Tras ejecutarlo, notamos que se ha creado una rama nueva (rama_nueva)
    * git checkout -b rama_nueva origin/rama_nueva # Crea una rama local a partir de la remota
    * git merge origin/nueva_rama # Equivalente a la de arriba, pero sin establecer el tracking a la rama

    * git push [remotename] :[branch] # elimina una rama remota
    * **git push [remotename] [localbranch]:[remotebranch] ** # La rama en el servidor tiene distinto nombre a la local ## TRACKING BRANCHES

    * git checkout --track origin/rama # Equivalente a -b rama_nueva origin/rama_nueva
    * git chekout -b &lt;nuevo_nombre&gt; origin/&lt;rama&gt; # Establece un nombre distinto para la rama local ## REBASE

* Rebase y merge se diferencian en que merge mezcla dos puntos finales de dos snapshots y rebase aplica cada uno de los cambios a la rama en la que se hace el rebase. No lo uses en repos publicos con mas colaboradores, porque todos los demas tendrán que hacer re-merges

* 
    * git checkout &lt;una rama&gt;
    * git rebase master # aplica todos los cambios de &lt;una rama&gt; a master
    * git merge master # hay que hacer un merge de tipo fast forward
    * Tenemos 3 ramas, master, client y server, en server y client tenemos varios commit y queremos mezclar client en master pero dejar server intacta:
    * git rebase --onto master server client # adivina los patches del antecesor común de las ramas server y client y aplica los cambios a master.
    * git checkout master*
    * git merge client # fast-forward. Client y master en el mismo snapshot
    * Si se quiere aplicar también los cambios de server, basta con:
    * git rebase master server*
    * git checkout master*
    * git merge server*

    * git rebase [basebranch] [topicbranch] # sintaxis de rebase
    * git rebase -i # Rebase interactivo

* # SERVIDOR

* 
    * git instawew # Muestra una interfaz web con los commits ## GENERAR UN NÚMERO DE COMPILACIÓN (BUILD NUMBER)

    * git describe master # Solo funciona para tags creadas con -s ó -a ## PREPARAR UNA RELEASE

    * git archive master -- prefix=”project/’ | gzip &gt; `git describe master`.tar.gz

    * 
        * git archive master -- prefix=”project/’ --format=zip | `git describe master`.zip
        * test/ export-ignore # Al crear el tarball no incluye el directorio test/

    * ## GENERAR UN CHANGELOG

    * 
        * git shortlog --no-merges master --not &lt;tag&gt; # Recopila todos los commits desde &lt;tag&gt; y los agrupa por autor

    * ## RECOMENDACIONES

    * 
        * Siempre hay que hacer pull antes de push en caso de que alguien haya subido cambios al servidor. Ejemplo:
        * User1 clona el repo y hace cambios, realiza un commit
        * User2 clona el repo, hace cambios, hace commit y sube los cambios con push
        * User1 intenta hacer push, pero será rechazado con: &lt;u&gt;! [rejected] master -&gt; master (non-fast forward)&lt;/u&gt;. No puede subir los cambios hasta que no mezcle el trabajo que ha subido User2. Así que debe hacer lo siguiente:

        * git fetch origin
        * git merge origin/master
        * git push origin master

        * Mientras User1 hacía estas operaciones, User2 ha creado una rama &lt;u&gt;issue54&lt;/u&gt; y realizado 3 commits, sin haber descargado los cambios de User1. Para sincronizar el trabajo, User2 debe hacer:
        * git fetch origin
        * git log --no-merges origin/master ^issue54 # Observa qué cambios ha hecho User1
        * git checkout master
        * git merge issue54 &amp;&amp; git merge origin/master*
        * git push origin master*

        * git diff --check # Antes de hacer commit, ejecutar esto para ver si hemos añadido demasiados espacios que puedan causar problemas a los demás.
        * Commits pequeños que se centren en resolver un problema, no commits con grandes cambios.
        * git add --patch # En caso de hacer varios cambios en el mismo archivo
        * El mensaje del commit debe tener la estructura siguiente: Una linea de no más de 50 caracteres, seguida de otra línea en blanco seguida de una descripción completa del commit.

    * ## PASOS A SEGUIR PARA CONTRIBUIR A PROYECYOS AJENOS, MEDIANTE FORK

    * 
        * git clone &lt;url&gt;
        * git checkout -b featureA
        * git commit
        * git remote add myFork &lt;url&gt;
        * git push myFork featureA
        * git request-pull origin/master myFork # enviar la salida por mail al propietario del proyecto, o hacer click en pull request.
        * Buena practica tener siempre una rama master que apunte a origin/master, para estar siempre actualizado con los ultimos cambios en el proyecto original.
        * Separar cada trabajo realizado en topic branch, que trackeen a origin/master

        * git checkout -b featureB origin/master
        * (Hacer cambios)
        * git commit
        * git push myFork featureB
        * (Contactar con el propietario del proyecto)
        * git fetch origin

        * Otro ejemplo, el propietario del proyecto quiere aceptar un pull tuyo, pero quiere que hagas algunos cambios, aprovechas la oportunidad y mueves tu trabajo para basarlo en el contenido actual de la rama origin/master, aplastas los cambios enfeatureB, resuelves conflictos, y haces push:

        * git checkout -b featureBv2 origin/master
        * git merge --no-commit --squash featureB
        * (cambiar la implementacion)
        * git commit
        * git push myFork featureBv2

        * --squash coge todo el trabajo de la rama mezclada y la aplasta en un no-merge commit encima de la rama en la que estas. --no-commit no registra el commit automaticamente. Así puedes realizar todos los cambios necesarios y luego hacer el commit

    * En segundo plano, git crea un log de a donde han estado referenciando HEAD y el resto de ramas en los últimos meses.
</code></pre>

<h2 id="reflog">REFLOG</h2>

<pre><code>    * 
        * git reflog*
        * **git show HEAD@{n} ** # Muestra información sobre el reflog número n
        * git log -g master # Muestra el log formateado como la salida de reflog
        * **git show master@{yesterday} ** # Muestra los commits de ayer.

    * ## UTILIDADES

    * 
        * git show &lt;short-SHA-1&gt; # Es posible ver un commit pasando la versión abreviada del SHA-1
        * git rev-parse &lt;branch&gt; # A qué SHA-1 apunta una rama
        * **git show HEAD^ ** # Muestra commit padre
        * git show HEAD^2 # Muestra segundo padre
        * git show HEAD~2 # El primer padre del primer padre
        * git filter-branch --tree-filter ‘rm -f &lt;file&gt;’ HEAD # elimina el archivo de todos los commits

    * ## DEPURACIÓN

    * 
        * File anotation
        * git blame -L 12,22 &lt;archivo&gt; # muestra cuando y por quién se modificaron de la linea 12 a la 22
        * git blame -C -L 141,153 &lt;file&gt; # cuando renombras un archivo o lo refactorizas en varios, muestra de donde vino originalmente.

        * Búsqueda Binaria: Cuando hay un bug que no puedes localizar, usas bisect para dererminar en qué commit empezó a producirse el bug.
        * git bisect start*
        * git bisect bad # marcas el commit actual como roto
        * **git bisect good [commit bueno] ** # último commit conocido que funcionaba
        * Ahora irá preguntando hasta que encuentres el commit culpable. Si esta bien indicas git bisect good. De lo contrario git bisect bad. Al terminar hay que resetear.
        * git bisect reset

    * ## SUBMODULOS

    * 
        * git submodule add &lt;url&gt; # crea un directorio que contiene el comtenido de otro proyecto.

        * Clonar un repo con submodulos
        * git clone url
        * git submodule init
        * git submodule update

    * ## CONFIGURATION

    * 
        * git config --global &lt;opcion&gt; &lt;valor&gt; # global para usuario, system todos y sin nada, especifico para el repo.
        * **git config {key} ** # muestra el valor de key
        * git config --global core.editor &lt;editor&gt; # cambia el editor por defecto
        * git config --global commit.template $HOME/.gitmessage.txt # plantilla para commits
        * **git config --global core.pager ‘moreless’** # paginador por defecto, puedes usar cualquiera
        * git config --global user.signingkey &lt;gpg-key-id&gt; # clave gpg para firmar tags
        * git config --global core.excludesfile &lt;file&gt; # como gitignore
        * git config --global help.autocorrect 1 # autocorrige cuando se escribe un comando incorrecto. Solo en git &gt;= 1.6.1
        * git config --global color.ui true # colorea la salida de git. Valores: truefalsealways
        * git config --global core.autocrlf input # para que usuarios linux no tengan problemas con los retornos de carro de windows
        * git config --global core.autocrlf true # para usuarios de windows
        * git config --global core.whitespace trailing-space, space-before-tab, indent-with-non-tab, cr-at-eol # respectivamente: busca espacios al final de línea, busca espacios al inicio de tabulación, busca líneas con 8 o más espacios en lugar de tabulaciones, acepta retornos de carro
        * git apply --whitespace=warn &lt;patch&gt; # advierte de errores de espacios antes de aplicar el patch. Con --whitespace=fix intenta arreglarlos

    * Otro ejemplo interesante es la expansión de la palabra clave$Date$. Para ello hay que escribir un script en ruby que recibe un archivo, encuentra la fecha de su último commit e inserta dicha fecha en el archivo:
</code></pre>

<p>git config &ndash;global filter.indent.smudge cat
git config &ndash;global filter.indent.clean indent
<em>.c filter=indentLuego:
Procesar archivos antes de hacer commit y antes de hacer checkout: Es posible crear tus propios filtros para hacer sustitución. Estos filtros se llamansmudgeyclean. Los puedes configurar para distintos directorios y luego escribir un script que procesará cada archivo antes de que sea checkeado (smudge) y commiteado (clean). Para ello,escribe en el .gitattributes: (En caso que quieras procesar código C)
Es posible hacer lo mismo para imágenes jpeg, es necesario instalarexiftoolpara extraer los metadatos y luego hacer:
echo ‘</em>.jpeg diff=exif’ » .gitattributes
git config diff.exif.textconv exiftool
Diffing binary files
En ocasiones es útil mostrar diffs de archivos binarios, como una archivo de word:
*.doc diff=word
#tras esto hay que definir el filtro word para que git convierta archivos word a texto:
git config diff.word.textconv strings
Identificando archivos binarios
Muchos archivos son para uso local y no aportan información al repositorio. Para decirle a git qué archivos son binarios hacer añadir al archivo atributes:
<nombre archivo o regexp> -crlf -diff # git no intentará corregir problemas de crlf ni mostrará los cambios con diff. En versiones &gt;= 1.6 se pueden sustituir estos dos valores por la macro binary
Archivo en .gitattributes en el directorio de trabajo o en .git/info/attributes para no committearlo</p>

<h2 id="git-attributes">GIT ATTRIBUTES</h2>

<p>#! /usr/bin/env ruby
  STDIN
last_date  <code>git log --pretty=format:&quot;%ad&quot; -1</code>
 &lsquo;$Date$&rsquo; &lsquo;$Date: &lsquo;  last_date<br />
Puedes nombrar este script comoexpand_date. Crea un filtro en git, llamado dater y dile que use el script anterior:
git config filter.dater.smudge expand_date
git config filter.dater.clean ‘perl -pe “s/\$Date[^\$]*\$/\$Date\$/”‘
Para usar el filtro, simplemente escribe la palabra clave en los archivos que desees:
*echo ‘# $Date$’ &gt; date_test.txt
echo ‘date.txt filter=dater’ » .gitattributes
git add date_test.txt .gitattributes
git commit -m “Testing date expansion in Git”
rm date_test.txt
git checkout date_test.txt
cat date_test.txt
$Date: Tue Apr 21 07:26:52 2009 -0700$</p>

	</section>
    </div>

    <footer class="site-footer">
	<p class="text">&copy; 2017 - © lPinchol Moon.<br>Powered by <a href="//gohugo.io/">Hugo</a> with the <a href="//github.com/digitalcraftsman/hugo-type-theme">Type Theme</a></p>
</footer>


<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89564434-1', 'auto');
ga('send', 'pageview');
</script>

</body>
</html>
